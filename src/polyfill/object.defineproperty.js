import {
	prototypeOfObject,
	isPrimitive,
	supportsAccessors,
	lookupGetter,
	lookupSetter,
	defineGetter,
	defineSetter
} from "./helpers";

// ES5 15.2.3.6
// http://es5.github.com/#x15.2.3.6

// Patch for WebKit and IE8 standard mode
// Designed by hax <hax.github.com>
// related issue: https://github.com/es-shims/es5-shim/issues#issue/5
// IE8 Reference:
//     http://msdn.microsoft.com/en-us/library/dd282900.aspx
//     http://msdn.microsoft.com/en-us/library/dd229916.aspx
// WebKit Bugs:
//     https://bugs.webkit.org/show_bug.cgi?id=36423

var doesDefinePropertyWork = function doesDefinePropertyWork(object) {
	try {
		Object.defineProperty(object, "sentinel", {});
		return "sentinel" in object;
	} catch (exception) {
		return false;
	}
};

// check whether defineProperty works if it's given. Otherwise,
// shim partially.
if (Object.defineProperty) {
	var definePropertyWorksOnObject = doesDefinePropertyWork({});
	var definePropertyWorksOnDom =
		typeof document === "undefined" ||
		doesDefinePropertyWork(document.createElement("div"));
	if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
		var definePropertyFallback = Object.defineProperty,
			definePropertiesFallback = Object.defineProperties;
	}
}

if (!Object.defineProperty || definePropertyFallback) {
	var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
	var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
	var ERR_ACCESSORS_NOT_SUPPORTED =
		"getters & setters can not be defined on this javascript engine";

	Object.defineProperty = function defineProperty(
		object,
		property,
		descriptor
	) {
		if (isPrimitive(object)) {
			throw new TypeError(ERR_NON_OBJECT_TARGET + object);
		}
		if (isPrimitive(descriptor)) {
			throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
		}
		// make a valiant attempt to use the real defineProperty
		// for I8's DOM elements.
		if (definePropertyFallback) {
			try {
				return definePropertyFallback.call(
					Object,
					object,
					property,
					descriptor
				);
			} catch (exception) {
				// try the shim if the real one doesn't work
			}
		}

		// If it's a data property.
		if ("value" in descriptor) {
			// fail silently if 'writable', 'enumerable', or 'configurable'
			// are requested but not supported
			/*
							// alternate approach:
							if ( // can't implement these features; allow false but not true
									('writable' in descriptor && !descriptor.writable) ||
									('enumerable' in descriptor && !descriptor.enumerable) ||
									('configurable' in descriptor && !descriptor.configurable)
							))
									throw new RangeError(
											'This implementation of Object.defineProperty does not support configurable, enumerable, or writable.'
									);
							*/

			if (
				supportsAccessors &&
				(lookupGetter(object, property) || lookupSetter(object, property))
			) {
				// As accessors are supported only on engines implementing
				// `__proto__` we can safely override `__proto__` while defining
				// a property to make sure that we don't hit an inherited
				// accessor.
				/* eslint-disable no-proto */
				var prototype = object.__proto__;
				object.__proto__ = prototypeOfObject;
				// Deleting a property anyway since getter / setter may be
				// defined on object itself.
				delete object[property];
				object[property] = descriptor.value;
				// Setting original `__proto__` back now.
				object.__proto__ = prototype;
				/* eslint-enable no-proto */
			} else {
				object[property] = descriptor.value;
			}
		} else {
			var hasGetter = "get" in descriptor;
			var hasSetter = "set" in descriptor;
			if (!supportsAccessors && (hasGetter || hasSetter)) {
				throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
			}
			// If we got that far then getters and setters can be defined !!
			if (hasGetter) {
				defineGetter(object, property, descriptor.get);
			}
			if (hasSetter) {
				defineSetter(object, property, descriptor.set);
			}
		}
		return object;
	};
}

// ES5 15.2.3.7
// http://es5.github.com/#x15.2.3.7
if (!Object.defineProperties || definePropertiesFallback) {
	Object.defineProperties = function defineProperties(object, properties) {
		// make a valiant attempt to use the real defineProperties
		if (definePropertiesFallback) {
			try {
				return definePropertiesFallback.call(Object, object, properties);
			} catch (exception) {
				// try the shim if the real one doesn't work
			}
		}

		Object.keys(properties).forEach(function(property) {
			if (property !== "__proto__") {
				Object.defineProperty(object, property, properties[property]);
			}
		});
		return object;
	};
}
